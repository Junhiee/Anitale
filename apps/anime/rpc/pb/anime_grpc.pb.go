// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: apps/anime/rpc/desc/proto/anime.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AnimeService_AnimeList_FullMethodName        = "/anime.AnimeService/AnimeList"
	AnimeService_GetAnime_FullMethodName         = "/anime.AnimeService/GetAnime"
	AnimeService_AddAnime_FullMethodName         = "/anime.AnimeService/AddAnime"
	AnimeService_DeleteAnime_FullMethodName      = "/anime.AnimeService/DeleteAnime"
	AnimeService_UpdateAnime_FullMethodName      = "/anime.AnimeService/UpdateAnime"
	AnimeService_Rank_FullMethodName             = "/anime.AnimeService/Rank"
	AnimeService_GetEpisodeList_FullMethodName   = "/anime.AnimeService/GetEpisodeList"
	AnimeService_AddEpisodes_FullMethodName      = "/anime.AnimeService/AddEpisodes"
	AnimeService_UpdateEpisodes_FullMethodName   = "/anime.AnimeService/UpdateEpisodes"
	AnimeService_GetCharacterList_FullMethodName = "/anime.AnimeService/GetCharacterList"
	AnimeService_GetTags_FullMethodName          = "/anime.AnimeService/GetTags"
)

// AnimeServiceClient is the client API for AnimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnimeServiceClient interface {
	// Anime
	AnimeList(ctx context.Context, in *AnimeListReq, opts ...grpc.CallOption) (*AnimeListResp, error)
	GetAnime(ctx context.Context, in *GetAnimeReq, opts ...grpc.CallOption) (*GetAnimeResp, error)
	AddAnime(ctx context.Context, in *AddAnimeReq, opts ...grpc.CallOption) (*AddAnimeResp, error)
	DeleteAnime(ctx context.Context, in *DeleteAnimeReq, opts ...grpc.CallOption) (*DeleteAnimeResp, error)
	UpdateAnime(ctx context.Context, in *UpdateAnimeReq, opts ...grpc.CallOption) (*UpdateAnimeResp, error)
	Rank(ctx context.Context, in *RankReq, opts ...grpc.CallOption) (*AnimeListResp, error)
	// Anime Episodes
	GetEpisodeList(ctx context.Context, in *GetEpisodesReq, opts ...grpc.CallOption) (*GetEpisodeListResp, error)
	AddEpisodes(ctx context.Context, in *AddEpisodesReq, opts ...grpc.CallOption) (*AddEpisodesResp, error)
	UpdateEpisodes(ctx context.Context, in *UpdateEpisodesReq, opts ...grpc.CallOption) (*UpdateEpisodesResp, error)
	// Anime Character
	GetCharacterList(ctx context.Context, in *GetCharacterReq, opts ...grpc.CallOption) (*GetCharacterListResp, error)
	// Anime Tag
	GetTags(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*TagResp, error)
}

type animeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAnimeServiceClient(cc grpc.ClientConnInterface) AnimeServiceClient {
	return &animeServiceClient{cc}
}

func (c *animeServiceClient) AnimeList(ctx context.Context, in *AnimeListReq, opts ...grpc.CallOption) (*AnimeListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnimeListResp)
	err := c.cc.Invoke(ctx, AnimeService_AnimeList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) GetAnime(ctx context.Context, in *GetAnimeReq, opts ...grpc.CallOption) (*GetAnimeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAnimeResp)
	err := c.cc.Invoke(ctx, AnimeService_GetAnime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) AddAnime(ctx context.Context, in *AddAnimeReq, opts ...grpc.CallOption) (*AddAnimeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddAnimeResp)
	err := c.cc.Invoke(ctx, AnimeService_AddAnime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) DeleteAnime(ctx context.Context, in *DeleteAnimeReq, opts ...grpc.CallOption) (*DeleteAnimeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAnimeResp)
	err := c.cc.Invoke(ctx, AnimeService_DeleteAnime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) UpdateAnime(ctx context.Context, in *UpdateAnimeReq, opts ...grpc.CallOption) (*UpdateAnimeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAnimeResp)
	err := c.cc.Invoke(ctx, AnimeService_UpdateAnime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) Rank(ctx context.Context, in *RankReq, opts ...grpc.CallOption) (*AnimeListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnimeListResp)
	err := c.cc.Invoke(ctx, AnimeService_Rank_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) GetEpisodeList(ctx context.Context, in *GetEpisodesReq, opts ...grpc.CallOption) (*GetEpisodeListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEpisodeListResp)
	err := c.cc.Invoke(ctx, AnimeService_GetEpisodeList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) AddEpisodes(ctx context.Context, in *AddEpisodesReq, opts ...grpc.CallOption) (*AddEpisodesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddEpisodesResp)
	err := c.cc.Invoke(ctx, AnimeService_AddEpisodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) UpdateEpisodes(ctx context.Context, in *UpdateEpisodesReq, opts ...grpc.CallOption) (*UpdateEpisodesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateEpisodesResp)
	err := c.cc.Invoke(ctx, AnimeService_UpdateEpisodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) GetCharacterList(ctx context.Context, in *GetCharacterReq, opts ...grpc.CallOption) (*GetCharacterListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCharacterListResp)
	err := c.cc.Invoke(ctx, AnimeService_GetCharacterList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *animeServiceClient) GetTags(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*TagResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TagResp)
	err := c.cc.Invoke(ctx, AnimeService_GetTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnimeServiceServer is the server API for AnimeService service.
// All implementations must embed UnimplementedAnimeServiceServer
// for forward compatibility.
type AnimeServiceServer interface {
	// Anime
	AnimeList(context.Context, *AnimeListReq) (*AnimeListResp, error)
	GetAnime(context.Context, *GetAnimeReq) (*GetAnimeResp, error)
	AddAnime(context.Context, *AddAnimeReq) (*AddAnimeResp, error)
	DeleteAnime(context.Context, *DeleteAnimeReq) (*DeleteAnimeResp, error)
	UpdateAnime(context.Context, *UpdateAnimeReq) (*UpdateAnimeResp, error)
	Rank(context.Context, *RankReq) (*AnimeListResp, error)
	// Anime Episodes
	GetEpisodeList(context.Context, *GetEpisodesReq) (*GetEpisodeListResp, error)
	AddEpisodes(context.Context, *AddEpisodesReq) (*AddEpisodesResp, error)
	UpdateEpisodes(context.Context, *UpdateEpisodesReq) (*UpdateEpisodesResp, error)
	// Anime Character
	GetCharacterList(context.Context, *GetCharacterReq) (*GetCharacterListResp, error)
	// Anime Tag
	GetTags(context.Context, *TagReq) (*TagResp, error)
	mustEmbedUnimplementedAnimeServiceServer()
}

// UnimplementedAnimeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAnimeServiceServer struct{}

func (UnimplementedAnimeServiceServer) AnimeList(context.Context, *AnimeListReq) (*AnimeListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnimeList not implemented")
}
func (UnimplementedAnimeServiceServer) GetAnime(context.Context, *GetAnimeReq) (*GetAnimeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnime not implemented")
}
func (UnimplementedAnimeServiceServer) AddAnime(context.Context, *AddAnimeReq) (*AddAnimeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAnime not implemented")
}
func (UnimplementedAnimeServiceServer) DeleteAnime(context.Context, *DeleteAnimeReq) (*DeleteAnimeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAnime not implemented")
}
func (UnimplementedAnimeServiceServer) UpdateAnime(context.Context, *UpdateAnimeReq) (*UpdateAnimeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAnime not implemented")
}
func (UnimplementedAnimeServiceServer) Rank(context.Context, *RankReq) (*AnimeListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rank not implemented")
}
func (UnimplementedAnimeServiceServer) GetEpisodeList(context.Context, *GetEpisodesReq) (*GetEpisodeListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEpisodeList not implemented")
}
func (UnimplementedAnimeServiceServer) AddEpisodes(context.Context, *AddEpisodesReq) (*AddEpisodesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddEpisodes not implemented")
}
func (UnimplementedAnimeServiceServer) UpdateEpisodes(context.Context, *UpdateEpisodesReq) (*UpdateEpisodesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEpisodes not implemented")
}
func (UnimplementedAnimeServiceServer) GetCharacterList(context.Context, *GetCharacterReq) (*GetCharacterListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCharacterList not implemented")
}
func (UnimplementedAnimeServiceServer) GetTags(context.Context, *TagReq) (*TagResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTags not implemented")
}
func (UnimplementedAnimeServiceServer) mustEmbedUnimplementedAnimeServiceServer() {}
func (UnimplementedAnimeServiceServer) testEmbeddedByValue()                      {}

// UnsafeAnimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnimeServiceServer will
// result in compilation errors.
type UnsafeAnimeServiceServer interface {
	mustEmbedUnimplementedAnimeServiceServer()
}

func RegisterAnimeServiceServer(s grpc.ServiceRegistrar, srv AnimeServiceServer) {
	// If the following call pancis, it indicates UnimplementedAnimeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AnimeService_ServiceDesc, srv)
}

func _AnimeService_AnimeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnimeListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).AnimeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_AnimeList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).AnimeList(ctx, req.(*AnimeListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_GetAnime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).GetAnime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_GetAnime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).GetAnime(ctx, req.(*GetAnimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_AddAnime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAnimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).AddAnime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_AddAnime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).AddAnime(ctx, req.(*AddAnimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_DeleteAnime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAnimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).DeleteAnime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_DeleteAnime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).DeleteAnime(ctx, req.(*DeleteAnimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_UpdateAnime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAnimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).UpdateAnime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_UpdateAnime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).UpdateAnime(ctx, req.(*UpdateAnimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_Rank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).Rank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_Rank_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).Rank(ctx, req.(*RankReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_GetEpisodeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEpisodesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).GetEpisodeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_GetEpisodeList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).GetEpisodeList(ctx, req.(*GetEpisodesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_AddEpisodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddEpisodesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).AddEpisodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_AddEpisodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).AddEpisodes(ctx, req.(*AddEpisodesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_UpdateEpisodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEpisodesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).UpdateEpisodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_UpdateEpisodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).UpdateEpisodes(ctx, req.(*UpdateEpisodesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_GetCharacterList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCharacterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).GetCharacterList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_GetCharacterList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).GetCharacterList(ctx, req.(*GetCharacterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnimeService_GetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnimeServiceServer).GetTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnimeService_GetTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnimeServiceServer).GetTags(ctx, req.(*TagReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AnimeService_ServiceDesc is the grpc.ServiceDesc for AnimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AnimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "anime.AnimeService",
	HandlerType: (*AnimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AnimeList",
			Handler:    _AnimeService_AnimeList_Handler,
		},
		{
			MethodName: "GetAnime",
			Handler:    _AnimeService_GetAnime_Handler,
		},
		{
			MethodName: "AddAnime",
			Handler:    _AnimeService_AddAnime_Handler,
		},
		{
			MethodName: "DeleteAnime",
			Handler:    _AnimeService_DeleteAnime_Handler,
		},
		{
			MethodName: "UpdateAnime",
			Handler:    _AnimeService_UpdateAnime_Handler,
		},
		{
			MethodName: "Rank",
			Handler:    _AnimeService_Rank_Handler,
		},
		{
			MethodName: "GetEpisodeList",
			Handler:    _AnimeService_GetEpisodeList_Handler,
		},
		{
			MethodName: "AddEpisodes",
			Handler:    _AnimeService_AddEpisodes_Handler,
		},
		{
			MethodName: "UpdateEpisodes",
			Handler:    _AnimeService_UpdateEpisodes_Handler,
		},
		{
			MethodName: "GetCharacterList",
			Handler:    _AnimeService_GetCharacterList_Handler,
		},
		{
			MethodName: "GetTags",
			Handler:    _AnimeService_GetTags_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "apps/anime/rpc/desc/proto/anime.proto",
}
